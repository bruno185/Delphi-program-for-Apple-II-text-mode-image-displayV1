unit Unit1;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, ShellApi, Vcl.StdCtrls;

type
  TForm1 = class(TForm)
    Button1: TButton;
    Memo1: TMemo;
    Label1: TLabel;
    Edit1: TEdit;
    procedure Button1Click(Sender: TObject);
    procedure FormCreate(Sender: TObject);
  private
    { Déclarations privées }
    procedure WMDropFiles(var msg : TMessage); message WM_DROPFILES;
  public
    { Déclarations publiques }
  end;

  bytefile = file of Byte;

var
  Form1: TForm1;

implementation

{$R *.dfm}

procedure doread(var f: bytefile; n : integer);
var
  i : integer;
  c : byte;
begin
  for i := 1 to n do read(f,c);
end;

function readint4(var f: bytefile) : integer;
var
  a,b,c,d : byte;
begin
  read(f,a);
  read(f,b);
  read(f,c);
  read(f,d);
  readint4 := a+b*256+c*256*256+d*256*256*256;
end;

function readint2(var f: bytefile) : integer;
var
  a,b : byte;
begin
  read(f,a);
  read(f,b);
  readint2 := a+b*256;
end;

procedure TForm1.Button1Click(Sender: TObject);
var
  filin : bytefile;
  filout : textfile;
  temp,i,j : integer;
  b, bhi,blo,l,val : byte;
  line : array [0..39] of byte;
  written : integer;
  bw : integer;
  sa : array [1..23] of string;


  procedure Header;
  begin
    doread(filin,2);
    temp := readint4(filin);
    memo1.Lines.Add('Total size : ' + IntToStr(temp)+ ' ($' + IntToHex(temp,1)+')');
    Doread(filin,4); // reserved
    temp := readint4(filin);
    memo1.Lines.Add('Image offset  : ' + IntToStr(temp)+ ' ($' + IntToHex(temp,1)+')');
    Doread(filin,4); // entete
    temp := readint4(filin);
    memo1.Lines.Add('Width : ' + IntToStr(temp)+ ' ($' + IntToHex(temp,1)+')');
    temp := readint4(filin);
    memo1.Lines.Add('Heigth : ' + IntToStr(temp)+ ' ($' + IntToHex(temp,1)+')');
    Doread(filin,2); // layers (always 1)
    temp := readint2(filin);
    memo1.Lines.Add('Bits/pixel : ' + IntToStr(temp)+ ' ($' + IntToHex(temp,1)+')');
    temp := readint4(filin);
    memo1.Lines.Add('Compression : ' + IntToStr(temp)+ ' ($' + IntToHex(temp,1)+')');
    temp := readint4(filin);
    memo1.Lines.Add('Image size : ' + IntToStr(temp)+ ' ($' + IntToHex(temp,1)+')');
    temp := readint4(filin);
    memo1.Lines.Add('H res. : ' + IntToStr(temp)+ ' ($' + IntToHex(temp,1)+')');
    temp := readint4(filin);
    memo1.Lines.Add('V res. : ' + IntToStr(temp)+ ' ($' + IntToHex(temp,1)+')');
    temp := readint4(filin);
    memo1.Lines.Add('Palette colors : ' + IntToStr(temp)+ ' ($' + IntToHex(temp,1)+')');
    temp := readint4(filin);
    memo1.Lines.Add('Imp. colors : ' + IntToStr(temp)+ ' ($' + IntToHex(temp,1)+')');
    doread(filin,64);    // palette
  end;

 procedure Init;
 var
  j:integer;
 begin
  memo1.Clear;

  assignfile(filin,'C:\A\a2apple30th\ag4023.bmp');
  //assignfile(filin,'F:\Bruno\Dev\AppleWin\Projets\a2apple30th\ag4023.bmp');
  reset(filin);

  // assignfile(filout,'F:\Bruno\Dev\AppleWin\Projets\a2apple30th\output.txt');
  assignfile(filout,'C:\A\a2apple30th\output.txt');
  rewrite(filout);
  bw := 0;
  for j:=1 to 23 do
    sa[j] := '';

  // Header
  memo1.Lines.Add('Header :');
  Header;
 end;



procedure DoWriteByte0;
begin
  if bw mod 4 = 0  then
  begin
    sa[j]:= sa[j] + #13#10;
    //writeln(filout);
    sa[j]:= sa[j] + ' db $'+IntToHex(b,2);
    //write(filout,' db $'+IntToHex(b,2));
  end
  else
  begin
    sa[j]:= sa[j] + ', $'+IntToHex(b,2);
    //write(filout,', $'+IntToHex(b,2));
  end;
  bw := bw + 1;
  written :=  written +l;
end;

procedure DoWriteByte;
begin
  sa[j]:= sa[j] + IntToHex(b,2);
  written :=  written +l;
end;

  // START HERE
begin
  //--------- init. ---------
   Init;

  // Data
  memo1.Lines.Add('');
  memo1.Lines.Add('Data :');
    //--------- starts here ---------

  for j := 1 to 23  do  // 23 lines
  begin
    for i := 0 to 19  do    // 20 bytes = 40 pixels
    begin
      read(filin,b);
      bhi := b shr 4;  // 1st pixel  (= hi nibble)
      blo := b and 15 ;  // 2nd pixel ((= low nibble)
      // populate line array
      line[2*i] := bhi;
      line[2*i+1] := blo;
    end;

    l := 0;
    val := 0;
    written := 0;

    for i := 0 to 39  do
    begin

      // Length = 0
      //
      if l = 0 then
      begin
        l := 1;
        val := line[i];
      end

      else

      // Length > 0
      //
      begin
        if l =15 then  // max length = 15 (one nibble)
        begin
          // write previous data
          b := l*16 + val;
          DoWriteByte;
          // init. new data
          l:=1;
          val := line[i];
        end

        else

        if (val = line [i]) then    // same value as previous data
        begin
          // update length
          l := l +1;
        end

        else

        begin    // new value
          // write previous data
          b := l*16 + val;
          DoWriteByte;
          // init. new data
          l := 1;
          val := line[i];
        end;
      end;

    end;   // inner loop

    // write non written remaining data
      b := l*16 + val;
      DoWriteByte;
      memo1.Lines.Add(IntToStr(written));
  end;  // outter loop

  closefile(filin);

  // output data to file
  j := 23  ;
  bw := 0;
  repeat
    i := 1;
    repeat
      if bw mod 4 = 0 then
      begin
        writeln(filout);
        write(filout,' db $');
        write(filout, sa[j][i]);
        inc(i);
        write(filout, sa[j][i]);
        inc(i);

      end
      else
      begin
      write(filout,', $');
      write(filout, sa[j][i]);
      inc(i);
      write(filout, sa[j][i]);
      inc(i);
      end;
      inc (bw);
    until (i>length(sa[j]));
    dec(j);
  until (j = 0);

  closefile(filout);

end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  DragAcceptFiles(Handle, true);
end;

// drag n drop file
procedure TForm1.WMDropFiles(var msg : TMessage);
var
  hand: THandle;
  nbFich, i : integer;
  buf:array[0..254] of Char;
  begin
    hand:=msg.wParam;
    nbFich:= DragQueryFile(hand, 4294967295, buf, 254);
    for i:= 0 to nbFich - 1 do
    begin
      DragQueryFile(hand, i, buf, 254);
      Edit1.Text := buf;
    end;
    DragFinish(hand);
    //SetOutput;
end;

end.
